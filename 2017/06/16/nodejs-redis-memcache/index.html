<!doctype html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="nodejs,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="简单区别：  Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。 redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。"><meta name="keywords" content="nodejs"><meta property="og:type" content="article"><meta property="og:title" content="Redis和Memcache的区别分析"><meta property="og:url" content="http://yoursite.com/2017/06/16/nodejs-redis-memcache/index.html"><meta property="og:site_name" content="Mr.Hua&#39;s Blog"><meta property="og:description" content="简单区别：  Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。 redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。"><meta property="og:updated_time" content="2017-06-16T03:34:49.832Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis和Memcache的区别分析"><meta name="twitter:description" content="简单区别：  Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。 redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2017/06/16/nodejs-redis-memcache/"><title> Redis和Memcache的区别分析 | Mr.Hua's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Mr.Hua's Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">To Reload Some Important Article</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/16/nodejs-redis-memcache/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Mr.Hua"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Mr.Hua's Blog"> <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Mr.Hua's Blog" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Redis和Memcache的区别分析</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-16T11:34:48+08:00">2017-06-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nodejs/" itemprop="url" rel="index"><span itemprop="name">nodejs</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><a href="/2017/06/16/nodejs-redis-memcache/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2017/06/16/nodejs-redis-memcache/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>简单区别：</p><ol><li>Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。</li><li>redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<a id="more"></a> Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcached只是简单的K/V缓存</li></ol><p>下面是来自redis作者的说法（stackoverflow上面）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">You should not care too much about performances. Redis is faster per core with small values, but memcached is able to use multiple cores with a single executable and TCP port without help from the client. Also memcached is faster with big values in the order of 100k. Redis recently improved a lot about big values (unstable branch) but still memcached is faster in this use case. The point here is: nor one or the other will likely going to be your bottleneck for the query-per-second they can deliver.</div><div class="line">You should care about memory usage. For simple key-value pairs memcached is more memory efficient. If you use Redis hashes, Redis is more memory efficient. Depends on the use case.</div><div class="line">You should care about persistence and replication, two features only available in Redis. Even if your goal is to build a cache it helps that after an upgrade or a reboot your data are still there.</div><div class="line">You should care about the kind of operations you need. In Redis there are a lot of complex operations, even just considering the caching use case, you often can do a lot more in a single operation, without requiring data to be processed client side (a lot of I/O is sometimes needed). This operations are often as fast as plain GET and SET. So if you don’t need just GEt/SET but more complex things Redis can help a lot (think at timeline caching).</div></pre></td></tr></table></figure><p></p><p>有网友翻译如下[1]：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">没有必要过多的关注性能。由于Redis只使用单核，而Memcached可以使用多核，所以在比较上，平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。说了这么多，结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。</div><div class="line">你需要关注内存使用率。对于key-value这样简单的数据储存，memcache的内存使用率更高。如果采用hash结构，redis的内存使用率会更高。当然，这些都依赖于具体的应用场景。</div><div class="line">你需要关注关注数据持久化和主从复制时，只有redis拥有这两个特性。如果你的目标是构建一个缓存在升级或者重启后之前的数据不会丢失的话，那也只能选择redis。</div><div class="line">你应该关心你需要的操作。redis支持很多复杂的操作，甚至只考虑内存的使用情况，在一个单一操作里你常常可以做很多，而不需要将数据读取到客户端中（这样会需要很多的IO操作）。这些复杂的操作基本上和纯GET和POST操作一样快，所以你不只是需要GET/SET而是更多的操作时，redis会起很大的作用。</div><div class="line">对于两者的选择还是要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，我在项目里还是采用memcache，它也足够的稳定可靠。如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。</div></pre></td></tr></table></figure><p></p><p>其他：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。</div><div class="line">2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</div><div class="line">3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘</div><div class="line">4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10</div><div class="line">5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从</div><div class="line">6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）</div><div class="line">7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</div><div class="line">8、Redis支持数据的备份，即master-slave模式的数据备份。</div></pre></td></tr></table></figure><p></p><p>关于redis和memcache的不同，下面罗列了一些相关说法，供记录：</p><h1 id="redis和memecache的不同："><a href="#redis和memecache的不同：" class="headerlink" title="redis和memecache的不同："></a>redis和memecache的不同：</h1><h2 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h2><p>memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小<br>redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。</p><h2 id="数据支持类型："><a href="#数据支持类型：" class="headerlink" title="数据支持类型："></a>数据支持类型：</h2><p>redis在数据支持上要比memecache多的多。</p><h2 id="使用底层模型不同："><a href="#使用底层模型不同：" class="headerlink" title="使用底层模型不同："></a>使用底层模型不同：</h2><p>新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><h2 id="运行环境不同："><a href="#运行环境不同：" class="headerlink" title="运行环境不同："></a>运行环境不同：</h2><p>redis目前官方只支持Linux 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上</p><p>个人总结一下，有持久化需求或者对数据结构和处理有高级要求的应用，选择redis，其他简单的key/value存储，选择memcache。</p><h1 id="Memcached和Redis两种方案"><a href="#Memcached和Redis两种方案" class="headerlink" title="Memcached和Redis两种方案"></a>Memcached和Redis两种方案</h1><h2 id="Memcached介绍"><a href="#Memcached介绍" class="headerlink" title="Memcached介绍"></a>Memcached介绍</h2><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态、数据库驱动网站的速度，现在已被LiveJournal、hatena、Facebook、Vox、LiveJournal等公司所使用。</p><h2 id="Memcached工作方式分析"><a href="#Memcached工作方式分析" class="headerlink" title="Memcached工作方式分析"></a>Memcached工作方式分析</h2><p>许多Web应用都将数据保存到 RDBMS中，应用服务器从中读取数据并在浏览器中显示。 但随着数据量的增大、访问的集中，就会出现RDBMS的负担加重、数据库响应恶化、 网站显示延迟等重大影响。Memcached是高性能的分布式内存缓存服务器,通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web等应用的速度、 提高可扩展性。下图展示了memcache与数据库端协同工作情况：<br>这里写图片描述<br>其中的过程是这样的：<br>1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库。<br>2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。<br>3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据。</p><p>Memcached作为高速运行的分布式缓存服务器，具有以下的特点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.协议简单</div><div class="line">2.基于libevent的事件处理</div><div class="line">3.内置内存存储方式</div><div class="line">4.memcached不互相通信的分布式</div></pre></td></tr></table></figure><p></p><p>如何实现分布式可拓展性？<br>Memcached的分布式不是在服务器端实现的，而是在客户端应用中实现的，即通过内置算法制定目标数据的节点，如下图所示：<br>这里写图片描述</p><h2 id="Redis-介绍"><a href="#Redis-介绍" class="headerlink" title="Redis 介绍"></a>Redis 介绍</h2><p>Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步,当前 Redis的应用已经非常广泛，国内像新浪、淘宝，国外像 Flickr、Github等均在使用Redis的缓存服务。</p><h2 id="Redis-工作方式分析"><a href="#Redis-工作方式分析" class="headerlink" title="Redis 工作方式分析"></a>Redis 工作方式分析</h2><p>Redis作为一个高性能的key-value数据库具有以下特征：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.多样的数据模型</div><div class="line">2.持久化</div><div class="line">3.主从同步</div></pre></td></tr></table></figure><p></p><p>Redis支持丰富的数据类型，最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis通常将数据存储于内存中，或被配置为使用虚拟内存。Redis有一个很重要的特点就是它可以实现持久化数据，通过两种方式可以实现数据持久化：使用RDB快照的方式，将内存中的数据不断写入磁盘；或使用类似MySQL的AOF日志方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。</p><p>Redis如何实现分布式可拓展性？<br>2.8以前的版本：与Memcached一致，可以在客户端实现，也可以使用代理，twitter已开发出用于Redis和Memcached的代理Twemproxy 。<br>3.0 以后的版本：相较于Memcached只能采用客户端实现分布式存储，Redis则在服务器端构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。如图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384。<br>这里写图片描述</p><h1 id="综合结论"><a href="#综合结论" class="headerlink" title="综合结论"></a>综合结论</h1><p>应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。具体来说：</p><h2 id="性能上："><a href="#性能上：" class="headerlink" title="性能上："></a>性能上：</h2><p>性能上都很出色，具体到细节，由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比<br>Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</p><h2 id="内存空间和数据量大小："><a href="#内存空间和数据量大小：" class="headerlink" title="内存空间和数据量大小："></a>内存空间和数据量大小：</h2><p>MemCached可以修改最大内存，采用LRU算法。Redis增加了VM的特性，突破了物理内存的限制。</p><h2 id="操作便利上："><a href="#操作便利上：" class="headerlink" title="操作便利上："></a>操作便利上：</h2><p>MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积。</p><h2 id="可靠性上："><a href="#可靠性上：" class="headerlink" title="可靠性上："></a>可靠性上：</h2><p>MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价。</p><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。<br>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</p><h1 id="需要慎重考虑的部分"><a href="#需要慎重考虑的部分" class="headerlink" title="需要慎重考虑的部分"></a>需要慎重考虑的部分</h1><p>1.Memcached单个key-value大小有限，一个value最大只支持1MB，而Redis最大支持512MB<br>2.Memcached只是个内存缓存，对可靠性无要求；而Redis更倾向于内存数据库，因此对对可靠性方面要求比较高<br>3.从本质上讲，Memcached只是一个单一key-value内存Cache；而Redis则是一个数据结构内存数据库，支持五种数据类型，因此Redis除单纯缓存作用外，还可以处理一些简单的逻辑运算，Redis不仅可以缓存，而且还可以作为数据库用<br>4.新版本（3.0）的Redis是指集群分布式，也就是说集群本身均衡客户端请求，各个节点可以交流，可拓展行、可维护性更强大。</p></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/nodejs/" rel="tag"># nodejs</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/06/14/nodejs-pm2/" rel="next" title="Nodejs PM2  使用介绍"><i class="fa fa-chevron-left"></i> Nodejs PM2 使用介绍</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2017/06/16/nodejs-redis/" rel="prev" title="node环境下redis操作示例及常用命令汇总">node环境下redis操作示例及常用命令汇总<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div><script type="text/javascript">var duoshuoQuery={short_name:"yuzhiyun"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Mr.Hua"><p class="site-author-name" itemprop="name">Mr.Hua</p><p class="site-description motion-element" itemprop="description">About My Work Daily</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">98</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">29</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">33</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/your-user-name" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://twitter.com/your-user-name" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span><span class="links-of-author-item"><a href="http://weibo.com/your-user-name" target="_blank" title="微博"><i class="fa fa-fw fa-globe"></i> 微博</a></span><span class="links-of-author-item"><a href="http://douban.com/people/your-user-name" target="_blank" title="豆瓣"><i class="fa fa-fw fa-globe"></i> 豆瓣</a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#redis和memecache的不同："><span class="nav-number">1.</span> <span class="nav-text">redis和memecache的不同：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储方式："><span class="nav-number">1.1.</span> <span class="nav-text">存储方式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据支持类型："><span class="nav-number">1.2.</span> <span class="nav-text">数据支持类型：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用底层模型不同："><span class="nav-number">1.3.</span> <span class="nav-text">使用底层模型不同：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行环境不同："><span class="nav-number">1.4.</span> <span class="nav-text">运行环境不同：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Memcached和Redis两种方案"><span class="nav-number">2.</span> <span class="nav-text">Memcached和Redis两种方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Memcached介绍"><span class="nav-number">2.1.</span> <span class="nav-text">Memcached介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memcached工作方式分析"><span class="nav-number">2.2.</span> <span class="nav-text">Memcached工作方式分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-介绍"><span class="nav-number">2.3.</span> <span class="nav-text">Redis 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-工作方式分析"><span class="nav-number">2.4.</span> <span class="nav-text">Redis 工作方式分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#综合结论"><span class="nav-number">3.</span> <span class="nav-text">综合结论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#性能上："><span class="nav-number">3.1.</span> <span class="nav-text">性能上：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存空间和数据量大小："><span class="nav-number">3.2.</span> <span class="nav-text">内存空间和数据量大小：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作便利上："><span class="nav-number">3.3.</span> <span class="nav-text">操作便利上：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠性上："><span class="nav-number">3.4.</span> <span class="nav-text">可靠性上：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景："><span class="nav-number">3.5.</span> <span class="nav-text">应用场景：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#需要慎重考虑的部分"><span class="nav-number">4.</span> <span class="nav-text">需要慎重考虑的部分</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2017</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Mr.Hua</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">var duoshuoQuery={short_name:"huajiang1989"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script></body></html>