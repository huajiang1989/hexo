<!DOCTYPE html><html><head><title> TypeScript 2.1 新特性一览 | Mr.Hua&#39;s Blog</title><link rel="icon shortcut" type="image/ico" href="/img/favicon.png"><link rel="icon" sizes="192x192" href="/img/favicon.png"><link rel="apple-touch-icon" href="/img/favicon.png"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#0097A7"><meta name="author" content="Mr.Hua"><meta name="description" content="About My Work Daily"><meta name="keywords" content="null"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="apple-mobile-web-app-title" content="Title"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="480"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Mr.Hua&#39;s Blog"><meta property="og:url" content="http://yoursite.com"><meta property="og:type" content="blog"><meta property="og:title" content="TypeScript 2.1 新特性一览 | Mr.Hua&#39;s Blog"><meta property="og:description" content="About My Work Daily"><!--[if lte IE 9]><link rel="stylesheet" href="/css/ie-blocker.css"><script src="/js/ie-blocker.en.js"></script><![endif]--><link rel="stylesheet" href="/css/material.min.css"><link rel="stylesheet" href="/css/style.min.css"><style>body,html{font-family:Roboto,"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif}a{color:#00838F}#scheme-Paradox .hot_tags-count,#scheme-Paradox .sidebar-colored .sidebar-badge,#scheme-Paradox .sidebar-colored .sidebar-header,#scheme-Paradox .sidebar_archives-count,#search-form-label:after,#search-label,.mdl-card__media{background-color:#0097A7!important}#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus,#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover{color:#0097A7!important}#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a,#post_entry-right-info,.sidebar-colored .sidebar-nav li:hover>a,.sidebar-colored .sidebar-nav li:hover>a i,.sidebar-colored .sidebar-nav li>a:focus i,.sidebar-colored .sidebar-nav li>a:hover,.sidebar-colored .sidebar-nav li>a:hover i,.sidebar-colored .sidebar-nav>.open>a,.sidebar-colored .sidebar-nav>.open>a:focus,.sidebar-colored .sidebar-nav>.open>a:hover{color:#0097A7!important}.toTop{background:#757575!important}.material-layout .material-index>.material-nav,.material-layout .material-post>.material-nav,.material-nav a{color:#757575}#scheme-Paradox .MD-burger-layer{background-color:#757575}#scheme-Paradox #post-toc-trigger-btn{color:#757575}.post-toc a:hover{color:#00838F;text-decoration:underline}</style><style>body{background-color:#F5F5F5}#scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{background-color:#fff}</style><style>.fade{transition:all .8s linear;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}.fade.out{opacity:0}</style><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/css/highlight/obsidian.css"><script>var agent=navigator.userAgent.toLowerCase();agent.indexOf("ucbrowser")>0&&(document.write('<link rel="stylesheet" href="/css/uc.css">'),alert("由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。"))</script></head><body id="scheme-Paradox"><div class="material-layout mdl-js-layout has-drawer is-upgraded"><main class="material-layout__content" id="main"><div id="top"></div> <button class="MD-burger-icon sidebar-toggle"><span class="MD-burger-layer"></span></button> <button id="post-toc-trigger-btn" class="mdl-button mdl-js-button mdl-button--icon"> <i class="material-icons">format_list_numbered</i></button><ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#keyof-与查找类型"><span class="post-toc-number">1.</span> <span class="post-toc-text">keyof 与查找类型</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#映射类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">映射类型</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Partial-Readonly-Record-以及-Pick"><span class="post-toc-number">3.</span> <span class="post-toc-text">Partial, Readonly, Record 以及 Pick</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#对象的展开与剩余运算符"><span class="post-toc-number">4.</span> <span class="post-toc-text">对象的展开与剩余运算符</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#异步函数的向下编译"><span class="post-toc-number">5.</span> <span class="post-toc-text">异步函数的向下编译</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#支持外部工具库-tslib"><span class="post-toc-number">6.</span> <span class="post-toc-text">支持外部工具库 (tslib)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#未添加类型的导入"><span class="post-toc-number">7.</span> <span class="post-toc-text">未添加类型的导入</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#对-–target-ES2016-–target-ES2017-及-–target-ESNext-的支持"><span class="post-toc-number">8.</span> <span class="post-toc-text">对 –target ES2016, –target ES2017 及 –target ESNext 的支持</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#隐式-any-错误"><span class="post-toc-number">9.</span> <span class="post-toc-text">隐式 any 错误</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#对字面量类型更好的推断"><span class="post-toc-number">10.</span> <span class="post-toc-text">对字面量类型更好的推断</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#使用-super-的返回值作为-‘this’"><span class="post-toc-number">11.</span> <span class="post-toc-text">使用 super 的返回值作为 ‘this’</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#配置继承"><span class="post-toc-number">12.</span> <span class="post-toc-text">配置继承</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#新-–alwaysStrict-选项"><span class="post-toc-number">13.</span> <span class="post-toc-text">新 –alwaysStrict 选项</span></a></li></ol></ul><div class="material-post_container"><div class="material-post mdl-grid"><div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col"><div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50"><script>var randomNum;randomNum=Math.floor(5*Math.random()+1),$(".post_thumbnail-random").css("background-image","url(/img/random/"+randomNum+".png)")</script><p class="article-headline-p"> TypeScript 2.1 新特性一览</p></div><div class="mdl-color-text--grey-700 mdl-card__supporting-text meta"><div id="author-avatar"> <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"></div><div> <strong>Mr.Hua</strong> <span>Feb 16, 2017</span></div><div class="section-spacer"></div> <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"> <i class="material-icons" role="presentation">bookmark</i> <span class="visuallyhidden">bookmark</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button"><li class="mdl-menu__item"> <a class="post_tag-link" href="/tags/TypeScript/">TypeScript</a></li></ul> <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"> <i class="material-icons" role="presentation">share</i> <span class="visuallyhidden">share</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button"><a class="post_share-link" href="https://twitter.com/intent/tweet?text=TypeScript 2.1 新特性一览&url=http://yoursite.com//2017/02/16/typescript_2.1/index.html&via=Mr.Hua" target="_blank"><li class="mdl-menu__item"> شارك على Twitter</li></a><a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com//2017/02/16/typescript_2.1/index.html" target="_blank"><li class="mdl-menu__item"> شارك على Google+</li></a><a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=TypeScript 2.1 新特性一览&url=http://yoursite.com//2017/02/16/typescript_2.1/index.html&pic=&searchPic=false&style=simple" target="_blank"><li class="mdl-menu__item"> شارك على Weibo</li></a></ul></div><div id="post-content" class="markdown-Github mdl-color-text--grey-700 mdl-card__supporting-text fade out"><p>继 TypeScript 2.0 正式版发布两个半月后, TypeScript 2.1 也终于来了. 这次更新带来了不少有用的改进, 特别是查找/映射类型及 any 类型的推断. 除此之外, 也用上了新的代码生成机制. 以下则是译自官方 Wiki 的内容.<br>keyof 与查找类型</p><a id="more"></a><h1 id="keyof-与查找类型"><a href="#keyof-与查找类型" class="headerlink" title="keyof 与查找类型"></a>keyof 与查找类型</h1><p>在 JavaScript 生态里常常会有 API 接受属性名称作为参数的情况, 但到目前为止还无法表达这类 API 的类型关系.</p><p>入口索引类型查询或者说 keyof; 索引类型查询 keyof T 会得出 T 可能的属性名称的类型. keyof T 类型被认为是 string 的子类型.</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Person &#123;</div><div class="line">    <span class="attr">name</span>: string;</div><div class="line">    age: number;</div><div class="line">    location: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">type K1 = keyof Person; <span class="comment">// "name" | "age" | "location"</span></div><div class="line">type K2 = keyof Person[];  <span class="comment">// "length" | "push" | "pop" | "concat" | ...</span></div><div class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  <span class="comment">// string</span></div></pre></td></tr></table></figure><p></p><p>与之对应的是索引访问类型, 也叫作查找类型 (lookup types). 语法上, 它们看起来和元素访问完全相似, 但是是以类型的形式使用的:</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type P1 = Person[<span class="string">"name"</span>];  <span class="comment">// string</span></div><div class="line">type P2 = Person[<span class="string">"name"</span> | <span class="string">"age"</span>];  <span class="comment">// string | number</span></div><div class="line">type P3 = string[<span class="string">"charAt"</span>];  <span class="comment">// (pos: number) =&gt; string</span></div><div class="line">type P4 = string[][<span class="string">"push"</span>];  <span class="comment">// (...items: string[]) =&gt; number</span></div><div class="line">type P5 = string[][<span class="number">0</span>];  <span class="comment">// string</span></div></pre></td></tr></table></figure><p></p><p>你可以将这种形式与类型系统中的其他功能组合, 来获得类型安全的查找.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj[key];  <span class="comment">// 推断的类型为 T[K]</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K, value: T[K]</span>) </span>&#123;</div><div class="line">    obj[key] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = &#123; <span class="attr">foo</span>: <span class="number">10</span>, <span class="attr">bar</span>: <span class="string">"hello!"</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = getProperty(x, <span class="string">"foo"</span>); <span class="comment">// number</span></div><div class="line"><span class="keyword">let</span> bar = getProperty(x, <span class="string">"bar"</span>); <span class="comment">// string</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> oops = getProperty(x, <span class="string">"wargarbl"</span>); <span class="comment">// 错误! "wargarbl" 不满足类型 "foo" | "bar"</span></div><div class="line"></div><div class="line">setProperty(x, <span class="string">"foo"</span>, <span class="string">"string"</span>); <span class="comment">// 错误! string 应该是 number</span></div></pre></td></tr></table></figure><p></p><h1 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h1><p>一个常见的需求是取一个现有的类型, 并将他的所有属性转换为可选值. 假设我们有 Person 类型:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface Person &#123;</div><div class="line">    <span class="attr">name</span>: string;</div><div class="line">    age: number;</div><div class="line">    location: string;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>它的部分类型 (partial) 的版本会是这样:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface PartialPerson &#123;</div><div class="line">    name?: string;</div><div class="line">    age?: number;</div><div class="line">    location?: string;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>有了映射类型, PartialPerson 就可以被写作对于 Person 类型的一般化转换:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Partial&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">type PartialPerson = Partial&lt;Person&gt;;</div></pre></td></tr></table></figure><p></p><p>映射类型是获取字面量类型的并集, 再通过计算新对象的属性集合产生的. 它们和 Python 中的列表解析 相似, 但不是在列表中创建新的元素, 而是在类型中创建新的属性.</p><p>除了 Partial 之外, 映射类型可以表达很多有用的类型转换:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保持类型一致, 但使每一个属性变为只读</span></div><div class="line">type Readonly&lt;T&gt; = &#123;</div><div class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 相同的属性名称, 但使值为 Promise 而不是具体的值</span></div><div class="line">type Deferred&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]: <span class="built_in">Promise</span>&lt;T[P]&gt;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 为 T 的属性添加代理</span></div><div class="line">type Proxify&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]: &#123; get(): T[P]; set(v: T[P]): <span class="keyword">void</span> &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><h1 id="Partial-Readonly-Record-以及-Pick"><a href="#Partial-Readonly-Record-以及-Pick" class="headerlink" title="Partial, Readonly, Record 以及 Pick"></a>Partial, Readonly, Record 以及 Pick</h1><p>Partial 与 Readonly, 就像之前提到的, 是非常有用的结构. 你可以使用它们来描述一些常见的 JS 实践, 比如:</p><p>function assign<t>(obj: T, props: Partial<t>): void;<br>function freeze<t>(obj: T): Readonly<t>;<br>正因为如此, 它们现在默认被包含在了标准库中.</t></t></t></t></p><p>我们还引入了另外两种工具类型: Record 和 Pick.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从 T 挑选一些属性 K</span></div><div class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">pick</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, ...keys: K[]</span>): <span class="title">Pick</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;;</span></div><div class="line"></div><div class="line"><span class="title">const</span> <span class="title">nameAndAgeOnly</span> = <span class="title">pick</span>(<span class="params">person, <span class="string">"name"</span>, <span class="string">"age"</span></span>);  // &#123; name: string, <span class="attr">age</span>: number &#125;</div><div class="line"><span class="comment">// 对所有 T 类型的属性 K, 将它转换为 U</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapObject</span>&lt;<span class="title">K</span> <span class="title">extends</span> <span class="title">string</span> | <span class="title">number</span>, <span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">obj: Record&lt;K, T&gt;, f: (x: T</span>) =&gt; <span class="title">U</span>): <span class="title">Record</span>&lt;<span class="title">K</span>, <span class="title">U</span>&gt;;</span></div><div class="line"></div><div class="line"><span class="title">const</span> <span class="title">names</span> = &#123; foo: <span class="string">"hello"</span>, <span class="attr">bar</span>: <span class="string">"world"</span>, <span class="attr">baz</span>: <span class="string">"bye"</span> &#125;;</div><div class="line"><span class="keyword">const</span> lengths = mapObject(names, s =&gt; s.length);  <span class="comment">// &#123; foo: number, bar: number, baz: number &#125;</span></div></pre></td></tr></table></figure><p></p><h1 id="对象的展开与剩余运算符"><a href="#对象的展开与剩余运算符" class="headerlink" title="对象的展开与剩余运算符"></a>对象的展开与剩余运算符</h1><p>TypeScript 2.1 带来了对 ES2017 展开与剩余运算符的支持.</p><p>和数组的展开类似, 展开一个对象可以很方便地获得它的浅拷贝:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> copy = &#123; ...original &#125;;</div></pre></td></tr></table></figure><p></p><p>相似的, 你可以合并多个不同的对象. 在下面的例子中, merged 会有来自 foo, bar 和 baz 的属性.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> merged = &#123; ...foo, ...bar, ...baz &#125;;</div></pre></td></tr></table></figure><p></p><p>你也可以覆盖已有的属性和添加新的属性:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="string">"string"</span> &#125;;</div><div class="line"><span class="keyword">var</span> newObj = &#123;...obj, <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span>&#125;; <span class="comment">// &#123; x: number, y: number, z: number &#125;</span></div></pre></td></tr></table></figure><p></p><p>指定展开操作的顺序决定了那些属性的值会留在创建的对象里; 在靠后的展开中出现的属性会 “战胜” 之前创建的属性.</p><p>对象的剩余操作和对象的展开是对应的, 这样一来我们可以导出解构一个元素时被漏掉的其他属性.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; z, ...obj1 &#125; = obj;</div><div class="line">obj1; <span class="comment">// &#123;x: number, y: number&#125;;</span></div></pre></td></tr></table></figure><p></p><h1 id="异步函数的向下编译"><a href="#异步函数的向下编译" class="headerlink" title="异步函数的向下编译"></a>异步函数的向下编译</h1><p>这一特性在 TypeScript 2.1 前就已经被支持, 但仅仅是当编译到 ES6/ES2015 的时候. TypeScript 2.1 带来了编译到 ES3 和 ES5 运行时的能力, 意味着你可以自由地运用这项优势到任何你在使用的环境.</p><p>注意: 首先, 我们需要确保我们的运行时有和 ECMAScript 兼容的全局 Promise. 这可能需要使用一个 Promise 的实现, 或者依赖目标运行时中的实现. 我们还需要通过设置 lib 选项为像 “dom”, “es2015” 或者 “dom”, “es2015.promise”, “es5” 这样的值来确保 TypeScript 知道 Promise 存在.</p><p>例子tsconfig.json<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"compilerOptions"</span>: &#123;</div><div class="line">        <span class="string">"lib"</span>: [<span class="string">"dom"</span>, <span class="string">"es2015.promise"</span>, <span class="string">"es5"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>dramaticWelcome.ts<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds: number</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt;(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</div><div class="line">        setTimeout(resolve, milliseconds);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dramaticWelcome</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">        <span class="keyword">await</span> delay(<span class="number">500</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"世界!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">dramaticWelcome();</div></pre></td></tr></table></figure><p></p><p>编译和运行, 在 ES3/ES5 引擎中应该也会有正确的行为.</p><h1 id="支持外部工具库-tslib"><a href="#支持外部工具库-tslib" class="headerlink" title="支持外部工具库 (tslib)"></a>支持外部工具库 (tslib)</h1><p>TypeScript 会注入一些工具函数, 比如用于继承的 <strong>extends, 用于对象字面量与 JSX 元素中展开运算符的</strong> assign, 以及用于异步函数的 __awaiter.</p><p>过去我们有两个选择:</p><p>在所有需要的文件中注入这些工具函数, 或者<br>使用 –noEmitHelpers 完全不输出工具函数.<br>这两个选项很难满足已有的需求; 在每一个文件中加入这些工具函数对于关心包大小的客户来说是一个痛点. 而不包含工具函数又意味着客户需要维护自己的工具库.</p><p>TypeScript 2.1 允许在你的项目中将这些文件作为单独的模块引用, 而编译器则会在需要的时候导入它们.</p><p>首先, 安装 tslib 工具库:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install tslib</div></pre></td></tr></table></figure><p></p><p>接下来, 使用 –importHelpers 选项编译你的文件:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc --module commonjs --importHelpers a.ts</div></pre></td></tr></table></figure><p></p><p>所以使用以下作为输入, 输出的 .js 文件就会包含对 tslib 的引入, 并且使用其中的 ___assign 工具函数而不是将它输出在文件中.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"o"</span> &#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> copy = &#123; ...o &#125;;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> tslib_1 = <span class="built_in">require</span>(<span class="string">"tslib"</span>);</div><div class="line">exports.o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"o"</span> &#125;;</div><div class="line">exports.copy = tslib_1.__assign(&#123;&#125;, exports.o);</div></pre></td></tr></table></figure><p></p><h1 id="未添加类型的导入"><a href="#未添加类型的导入" class="headerlink" title="未添加类型的导入"></a>未添加类型的导入</h1><p>TypeScript 过去对于如何导入模块有一些过于严格. 这样的本意是避免拼写错误, 并且帮助用户正确地使用模块.</p><p>然而, 很多时候, 你可能仅仅是想导入一个没有它自己的 .d.ts 文件的现有模块. 之前这是会导致错误. 从 TypeScript 2.1 开始, 则会容易很多.</p><p>使用 TypeScript 2.1, 你可以导入一个 JavaScript 模块而无需类型声明. 类型声明 (比如 declare module “foo” { … } 或者 node_modules/@types/foo) 如果存在的话仍具有更高的优先级.</p><p>对没有声明文件的模块的导入, 在 –noImplicitAny 时仍会被标记为错误.</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果 `node_modules/asdf/index.js` 存在, 或 `node_modules/asdf/package.json` 定义了合法的 "main" 入口即可</span></div><div class="line"><span class="keyword">import</span> &#123; x &#125; <span class="keyword">from</span> <span class="string">"asdf"</span>;</div></pre></td></tr></table></figure><p></p><h1 id="对-–target-ES2016-–target-ES2017-及-–target-ESNext-的支持"><a href="#对-–target-ES2016-–target-ES2017-及-–target-ESNext-的支持" class="headerlink" title="对 –target ES2016, –target ES2017 及 –target ESNext 的支持"></a>对 –target ES2016, –target ES2017 及 –target ESNext 的支持</h1><p>TypeScript 2.1 支持了三个新的目标版本值 –target ES2016, –target ES2017 及 –target ESNext.</p><p>使用目标版本 –target ES2016 会告诉编译器不要对 ES2016 的特性进行转换, 比如 ** 运算符.</p><p>相似的, –target ES2017 会告诉编译器不要转换 ES2017 的特性, 比如 async/await.</p><p>–target ESNext 则对应最新的 ES 提案特性的支持.</p><p>改进的 any 推断</p><p>之前, 如果 TypeScript 不能弄明白一个变量的类型, 它会选择 any 类型.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;      <span class="comment">// 隐式的 'any'</span></div><div class="line"><span class="keyword">let</span> y = []; <span class="comment">// 隐式的 'any[]'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> z: any; <span class="comment">// 显式的 'any'.</span></div></pre></td></tr></table></figure><p></p><p>在 TypeScript 2.1 中, 不同于简单地选择 any, TypeScript 会根据之后的赋值推断类型.</p><p>这仅会在 –noImplicitAny 时开启.</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"></div><div class="line"><span class="comment">// 你仍可以将任何值赋给 'x'.</span></div><div class="line">x = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">// 在上一次赋值后, TypeScript 2.1 知道 'x' 的类型为 '() =&gt; number'.</span></div><div class="line"><span class="keyword">let</span> y = x();</div><div class="line"></div><div class="line"><span class="comment">// 得益于此, 它现在会告诉你你不能将一个数字和函数相加!</span></div><div class="line"><span class="built_in">console</span>.log(x + y);</div><div class="line"><span class="comment">//          ~~~~~</span></div><div class="line"><span class="comment">// 错误! 运算符 '+' 不能被使用在类型 '() =&gt; number' 和 'number' 上.</span></div><div class="line"></div><div class="line"><span class="comment">// TypeScript 仍允许你将任何值赋给 'x'</span></div><div class="line">x = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 但现在它也会知道 'x' 是 'string'!</span></div><div class="line">x.toLowerCase();</div></pre></td></tr></table></figure><p></p><p>同样的追踪现在对于空数组也会生效.</p><p>一个没有类型标注, 初始值为 [] 的变量声明被认为是一个隐式的 any[] 变量. 不过, 接下来的 x.push(value), x.unshift(value) 或者 x[n] = value 操作将依据添加的元素去演进变量的类型.<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = [];</div><div class="line">    x.push(<span class="number">5</span>);</div><div class="line">    x[<span class="number">1</span>] = <span class="string">"hello"</span>;</div><div class="line">    x.unshift(<span class="literal">true</span>);</div><div class="line">    <span class="keyword">return</span> x;  <span class="comment">// (string | number | boolean)[]</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (cond()) &#123;</div><div class="line">        x = [];</div><div class="line">        <span class="keyword">while</span> (cond()) &#123;</div><div class="line">            x.push(<span class="string">"hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x;  <span class="comment">// string[] | null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h1 id="隐式-any-错误"><a href="#隐式-any-错误" class="headerlink" title="隐式 any 错误"></a>隐式 any 错误</h1><p>这个特性的一大好处就是, 使用 –noImplicitAny 时你会看到的隐式 any 错误会比之前少非常多. 隐式 any 错误仅仅会在编译器不通过类型声明就无法知道变量类型时被报告.</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = [];  <span class="comment">// 错误: 变量 'x' 隐式地有类型 'any[]' 在一些位置的类型无法被确定.</span></div><div class="line">    x.push(<span class="number">5</span>);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        x;    <span class="comment">// 错误: 变量 'x' 隐式地有类型 'any[]'.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h1 id="对字面量类型更好的推断"><a href="#对字面量类型更好的推断" class="headerlink" title="对字面量类型更好的推断"></a>对字面量类型更好的推断</h1><p>字符串, 数字和布尔值字面量类型 (例如 “abc”, 1, 和 true) 在之前仅会在有显式的类型标注时被使用. 从 TypeScript 2.1 开始, 对于 const 变量和 readonly 属性, 字面量类型会始终作为推断的结果.</p><p>对于没有类型标注的 const 变量和 readonly 属性, 推断的类型为字面量初始值的类型. 对于有初始值, 没有类型标注的 let 变量, var 变量, 参数, 或者非 readonly 的属性, 推断的类型为拓宽的字面量初始值的类型. 这里拓宽的类型对于字符串字面量来说是 string, 对于数字字面量是 number, 对于 true 或 false 来说是 boolean, 对于枚举字面量类型则是对应的枚举类型.</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> c1 = <span class="number">1</span>;  <span class="comment">// 类型 1</span></div><div class="line"><span class="keyword">const</span> c2 = c1;  <span class="comment">// 类型 1</span></div><div class="line"><span class="keyword">const</span> c3 = <span class="string">"abc"</span>;  <span class="comment">// 类型 "abc"</span></div><div class="line"><span class="keyword">const</span> c4 = <span class="literal">true</span>;  <span class="comment">// 类型 true</span></div><div class="line"><span class="keyword">const</span> c5 = cond ? <span class="number">1</span> : <span class="string">"abc"</span>;  <span class="comment">// 类型 1 | "abc"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> v1 = <span class="number">1</span>;  <span class="comment">// 类型 number</span></div><div class="line"><span class="keyword">let</span> v2 = c2;  <span class="comment">// 类型 number</span></div><div class="line"><span class="keyword">let</span> v3 = c3;  <span class="comment">// 类型 string</span></div><div class="line"><span class="keyword">let</span> v4 = c4;  <span class="comment">// 类型 boolean</span></div><div class="line"><span class="keyword">let</span> v5 = c5;  <span class="comment">// 类型 number | string</span></div></pre></td></tr></table></figure><p></p><p>字面量类型的拓宽可以通过显式的类型标注来控制. 具体来说, 当一个有字面量类型的表达式是通过常量位置而不是类型标注被推断时, 这个 const 变量被推断的是待拓宽的字面量类型. 但在 const 位置有显式的类型标注时, const 变量获得的是非待拓宽的字面量类型.</p><p>例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> c1 = <span class="string">"hello"</span>;  <span class="comment">// 待拓宽类型 "hello"</span></div><div class="line"><span class="keyword">let</span> v1 = c1;  <span class="comment">// 类型 string</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> c2: <span class="string">"hello"</span> = <span class="string">"hello"</span>;  <span class="comment">// 类型 "hello"</span></div><div class="line"><span class="keyword">let</span> v2 = c2;  <span class="comment">// 类型 "hello"</span></div></pre></td></tr></table></figure><p></p><h1 id="使用-super-的返回值作为-‘this’"><a href="#使用-super-的返回值作为-‘this’" class="headerlink" title="使用 super 的返回值作为 ‘this’"></a>使用 super 的返回值作为 ‘this’</h1><p>在 ES2015 中, 返回对象的构造函数会隐式地替换所有 super() 调用者的 this 的值. 这样一来, 捕获 super() 任何潜在的返回值并使用 this 替代则是必要的. 这一项改变使得我们可以配合自定义元素, 而它正是利用了这一特性来初始化浏览器分配, 却是由用户编写了构造函数的元素.</p><p>Example<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    x: number;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// 返回一个不同于 `this` 的新对象</span></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.x = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>生成:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Derived = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</div><div class="line">    __extends(Derived, _super);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Derived</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _this = _super.call(<span class="keyword">this</span>) || <span class="keyword">this</span>;</div><div class="line">        _this.x = <span class="number">2</span>;</div><div class="line">        <span class="keyword">return</span> _this;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Derived;</div><div class="line">&#125;(Base));</div></pre></td></tr></table></figure><p></p><p>这一改变会引起对像 Error, Array, Map 等等的内建类的扩展行为带来不兼容的变化. 请参照扩展内建类型不兼容变化文档了解详情.</p><h1 id="配置继承"><a href="#配置继承" class="headerlink" title="配置继承"></a>配置继承</h1><p>一个项目通常会有多个输出目标, 比如 ES5 和 ES2015, 编译和生产或 CommonJS 和 System; 在这些成对的目标中, 只有少数配置选项会改变, 而维护多个 tsconfig.json 文件可以会比较麻烦.</p><p>TypeScript 2.1 支持通过 extends 来继承配置, 在这儿:</p><p>extends 是 tsconfig.json 中一个新的顶级属性 (同级的还有 compilerOptions, files, include 和 exclude).<br>extends 的值必须为一个包含了到另一个被继承的配置文件的路径的字符串.<br>基文件的配置会先被加载, 然后被继承它的文件内的配置覆盖.<br>配置文件不允许出现循环.<br>继承文件中的 files, include 和 exclude 会覆盖被继承的配置文件中对应的值.<br>所有配置文件中出现的相对路径会相对这些路径所配置文件的路径来解析.<br>例子<br>configs/base.json:<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"compilerOptions"</span>: &#123;</div><div class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>tsconfig.json:<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"extends"</span>: <span class="string">"./configs/base"</span>,</div><div class="line">  <span class="attr">"files"</span>: [</div><div class="line">    <span class="string">"main.ts"</span>,</div><div class="line">    <span class="string">"supplemental.ts"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>tsconfig.nostrictnull.json:<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"extends"</span>: <span class="string">"./tsconfig"</span>,</div><div class="line">  <span class="attr">"compilerOptions"</span>: &#123;</div><div class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h1 id="新-–alwaysStrict-选项"><a href="#新-–alwaysStrict-选项" class="headerlink" title="新 –alwaysStrict 选项"></a>新 –alwaysStrict 选项</h1><p>使用 –alwaysStrict 来启动编译器会使:</p><p>所有代码以严格模式进行解析.<br>在所有生成文件的顶部输出 “use strict”; 指令.<br>模块会自动以严格模式进行解析. 对于非模块代码推荐使用该新选项.</p></div><link rel="stylesheet" href="/css/duoshuo.min.css"><style>#ds-thread #ds-reset .ds-post-button{background-color:#0097A7!important}#ds-wrapper #ds-reset .ds-icons-32{background-color:#0097A7!important}#ds-reset .ds-highlight{color:#0097A7!important}</style><div id="comments"><div class="ds-thread" data-thread-key="2017/02/16/typescript_2.1/" data-url="http://yoursite.com/2017/02/16/typescript_2.1/" data-title="TypeScript 2.1 新特性一览"></div></div></div><nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col"><div class="section-spacer"></div> <a href="/2017/02/10/vue-com-pro/" id="post_nav-older" class="next-content">أقدم &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation"> <i class="material-icons">arrow_forward</i></button></a></nav></div></div><div class="sidebar-overlay"></div><aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation"><div id="sidebar-main"><div class="sidebar-header header-cover" style="background-image:url(/img/sidebar_header.png)"><div class="top-bar"></div> <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display:initial" data-upgraded=",MaterialButton,MaterialRipple"> <i class="material-icons">clear_all</i><span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></button><div class="sidebar-image"> <img src="/img/avatar.png" alt="Mr.Hua's avatar"></div> <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">472970338@qq.com<b class="caret"></b></a></div><ul class="nav sidebar-nav"><li class="dropdown"><ul id="settings-dropdown" class="dropdown-menu"><li> <a href="#" target="_blank" title="Email Me"><i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i> Email Me</a></li></ul></li><li id="sidebar-first-li"> <a href="/" target="_self"><i class="material-icons sidebar-material-icons">home</i> الرئيسية</a></li><li class="dropdown"> <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown"><i class="material-icons sidebar-material-icons">inbox</i> أرشيف<b class="caret"></b></a><ul class="dropdown-menu"><li> <a class="sidebar_archives-link" href="/archives/2017/02/">February 2017<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/01/">January 2017<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/12/">December 2016<span class="sidebar_archives-count">42</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/11/">November 2016<span class="sidebar_archives-count">4</span></a></li></ul></li><li class="divider"></li><li> <a href="/archives" title="archives">archives</a></li><li> <a href="/tags" title="tags">tags</a></li><li> <a href="/archives">رقم المقالة <span class="sidebar-badge">57</span></a></li></ul><div class="sidebar-divider"></div><a href="https://github.com/viosey/hexo-theme-material" class="sidebar-footer-text-a" target="_blank"><div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple"> سمة - Material <span class="sidebar-badge badge-circle">i</span></div></a></div></aside><div class="toTop-wrap"> <a href="#top" class="toTop"><i class="material-icons footer_top-i">expand_less</i></a></div><footer class="mdl-mini-footer" id="bottom"><div class="mdl-mini-footer--left-section sns-list"> <a href="https://twitter.com/twitter" target="view_window"><button class="mdl-mini-footer--social-btn social-btn" style="background-image:url(/img/footer/footer_ico-twitter.png)"> <span class="visuallyhidden">Twitter</span></button></a> <a href="https://www.facebook.com/facebook" target="view_window"><button class="mdl-mini-footer--social-btn social-btn" style="background-image:url(/img/footer/footer_ico-facebook.png)"> <span class="visuallyhidden">Facebook</span></button></a> <a href="https://www.google.com/" target="view_window"><button class="mdl-mini-footer--social-btn social-btn" style="background-image:url(/img/footer/footer_ico-gplus.png)"> <span class="visuallyhidden">Google Plus</span></button></a></div><div id="copyright">Copyright&nbsp;©&nbsp;<script type="text/javascript">var fd=new Date;document.write(fd.getFullYear())</script>&nbsp;Mr.Hua's Blog</div><div class="mdl-mini-footer--right-section"><div><div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div><div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div></div></div></footer><script src="/js/highlight.min.js"></script><script src="/js/js.min.js"></script><script src="/js/nprogress.js"></script><script type="text/javascript">NProgress.configure({showSpinner:!0}),NProgress.start(),$("#nprogress .bar").css({background:"#FF4081"}),$("#nprogress .peg").css({"box-shadow":"0 0 10px #FF4081, 0 0 15px #FF4081"}),$("#nprogress .spinner-icon").css({"border-top-color":"#FF4081","border-left-color":"#FF4081"}),setTimeout(function(){NProgress.done(),$(".fade").removeClass("out")},800)</script><script type="text/javascript">var duoshuoQuery={short_name:"huajiang1989"};!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://static.duoshuo.com/embed.js",e.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>$(window).load(function(){$(".post-toc-wrap").parent(".mdl-menu__container").css("position","fixed")})</script></main></div></body></html>